##
#
# First preliminary tests for R-code by Anni
# Functions
# 
##
##


## Calling basic blasso 

##### IN ######
## X: predictor matrix
## Y: response matrix
## K: kit matrix
## C: kit cost matrix
## iprint: specifies the print
## start: specifies how starting points are selected when the L0-norm problem is solved for the fixed number of kits 
##        in which order the L0-norm problems are solved

## JTN LISÄÄ? Esim 0/1 halutaanko CPU time yms statistiikkaa tulostaa
##

##### OUT ######
## f_for_k: The objective function values
## beta_for_k: The beta values for predictors
## CPUtime: the CPU time in seconds


blasso_loop_kits <- function(X,Y,K,C,iprint,start){
  
  if(!is.matrix(X)) stop("Predictor matrix 'X' should be of 'matrix' class.")
  if(!is.matrix(Y)) stop("Response matrix 'Y' should be of 'matrix' class.")
  if(!is.matrix(K)) stop("Kit matrix 'K' should be of 'matrix' class.")
  if(!is.matrix(C)) stop("Kit cost matrix 'C' should be of 'matrix' class.")
  
  ## iprint ja start tarkistus
  
  #
  nft <- ncol(X)      # Number of features
  nrecord <- nrow(X)  # Number of observations
  nkits <- nrow(K)    # Number of kits
  
  # Check dimensions
  if(nrow(Y)!=nrecord){
    stop(paste("Number of observations in the response matrix Y (",nrow(Y),") is not equal to number of observations in the predictor matrix X (",nrow(X),"). Please check both."))
  }
  if(ncol(Y)!=2){
    stop(paste("Incorrect number of columns in the response matrix Y (",ncol(Y),"). The number of columns should be 2."))
  }
  if(ncol(K)!=nft){
    stop(paste("Number of columns in kit matrix K (",ncol(K),") should be equal to the amount of features (",nft,"). Check that correct features are included."))
  }
  if(nrow(C)!=nkits){
    stop(paste("Number of kit costs (",nrow(C),") is not equal to number of kits (",nkits,"). Check that correct kits are included."))
  }
  
  ## Check that event is 0/1.
  if(!all(Y[,2] %in% c(0,1))){
    stop(paste("It seems that in the second column of the response matrix (Y) there is an event that is not 0 or 1. Check that the events are either 0 or 1.\n
               Additionally, check that the event is in the seconf column of response matrix."))
  }
  
  
  
  
  ## Make X and K into vectors (order: feature 1 all obs, feature 2 all obs, etc)
  inX <- as.vector(X)  # When making a vector from a matrix, it is done columnwise.
  inK <- as.vector(K)
  
  ## Check dimension of X and K
  if(length(inX)!= nft*nrecord){
    stop(paste("Length of vector X, made from the matrix X, differs from the actual amount of datapoints (nrow(X)*ncol(X))"))
  }
  if(length(inK)!= nft*nkits){
    stop(paste("Length of vector K, made from the matrix K, differs from the actual amount of datapoints (nrow(K)*ncol(K))"))
  }
  
  if(!is.double(inX)) { storage.mode(inX) <- 'double' }	
  if(!is.double(Y)) { storage.mode(Y) <- 'double' }	
  if(!is.double(inK)) { storage.mode(inK) <- 'double' }	
  if(!is.double(C)) { storage.mode(C) <- 'double' }	
  
  else{
    if(!is.integer(nft)) { storage.mode(nft) <- 'integer' }
    if(!is.integer(nrecord)) { storage.mode(nrecord) <- 'integer' }
    if(!is.integer(nkits)) { storage.mode(nkits) <- 'integer' }
    print(paste("R: nrow:", nrecord, "& ncol:", nft))
    
    ## HUOM! Pitäisikö C pyytää alkujaankin vektorina?
    result <- .Call(CKOODI,as.integer(nft),as.integer(nrecord),as.integer(nkits),as.double(inX),c(as.double(Y[,1]),as.double(Y[,2])),
                    as.double(inK),as.double(as.vector(C)),iprint,start)
  }
  if(exists(result)){
    return(result)
  }else{
    stop(paste("Result was not obtained."))
  }
}
